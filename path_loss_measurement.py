# -*- coding: utf-8 -*-
"""Path_Loss_Measurement.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-sYcjkOWv75buTl_TFuDNep2wdk3hTp0

**Modelos Teóricos**
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Modelo de Okumura-Hata
def okumura_hata(f, h_b, h_m, d, potencia_transmitida, ciudad_grande=True):

  if ciudad_grande:
      a_hm = 3.2 * (np.log10(11.75 * h_m))**2 - 4.97  # Ciudades grandes
  else:
      a_hm = (1.1 * np.log10(f) - 0.7) * h_m - (1.56 * np.log10(f) - 0.8)  # Ciudades pequeñas

  # Calcular Path Loss
  L = (69.55 + 26.16 * np.log10(f) - 13.82 * np.log10(h_b) - a_hm +
      (44.9 - 6.55 * np.log10(h_b)) * np.log10(d))

  # Calcular potencia recibida en dBm
  p_recibida = potencia_transmitida - L
  return p_recibida


# Modelo de Friis
def friis(f, d, potencia_transmitida):

  # Calcular Path Loss
  L = 20 * np.log10(d * 1000) + 20 * np.log10(f * (10 ** 6)) - 147.55

  # Calcular potencia recibida en dBm
  p_recibida = potencia_transmitida - L

  return p_recibida

def comparacion_teorica(distancias, potencia_transmitida, f, h_b, h_m):

    # Calcular las potencias recibidas utilizando los modelos Okumura-Hata y Friis
    p_recibida_hata = np.array([okumura_hata(f, h_b, h_m, d, potencia_transmitida) for d in distancias])
    p_recibida_friis = np.array([friis(f, d, potencia_transmitida) for d in distancias])

    # Crear la gráfica
    plt.figure(figsize=(10, 6))
    plt.plot(distancias, p_recibida_hata, label="Okumura-Hata (urbano)", color="blue")
    plt.plot(distancias, p_recibida_friis, label="Friis", color="orange", linestyle="--")

    # Etiquetas y título
    plt.title("Comparación de Modelos de Path Loss")
    plt.xlabel("Distancia (km)", fontsize=12)
    plt.ylabel("Potencia Recibida (dBm)", fontsize=12)
    plt.grid(True)
    plt.legend()
    plt.show()

# Parámetros
distancias = np.linspace(0.03, 0.24, 100)  # Distancias en km
potencia_transmitida = 30  # Potencia transmitida en dBm
f = 700  # Frecuencia en MHz
h_b = 40  # Altura de la antena base en metros
h_m = 1.5  # Altura de la antena móvil en metros

# Graficar las curvas de potencia recibida
comparacion_teorica(distancias, potencia_transmitida, f, h_b, h_m)

"""**Trabajo Práctico**

"""

import os
import pandas as pd
from google.colab import drive
import numpy as np

# Montar Google Drive
drive.mount('/content/drive')

carpeta = "/content/drive/My Drive/DatosPathLoss"

# Definir coordenadad antena

lat_antena = -33.456618
lng_antena = -70.666408

def ordenar_coordenadas(carpeta_csv, lat_base, lng_base):

    import os
    import glob

    # Crear una lista para almacenar las coordenadas y distancias
    coordenadas = []

    # Cargar todos los archivos CSV de la carpeta
    archivos = glob.glob(f"{carpeta_csv}/*.csv")

    for archivo in archivos:
        # El nombre del archivo contiene la latitud y longitud (asumido)
        nombre = os.path.basename(archivo).replace('.csv', '')
        try:
            # Cambiar el separador a "_" en lugar de ","
            lat, lng = map(float, nombre.split('_'))
        except ValueError:
            print(f"Formato inválido en el nombre del archivo: {nombre}")
            continue

        # Calcular la distancia a la antena
        distancia = np.sqrt((lat - lat_base)**2 + (lng - lng_base)**2)

        # Agregar la información a la lista
        coordenadas.append({'Archivo': archivo, 'Latitud': lat, 'Longitud': lng, 'Distancia': distancia})

    # Crear un DataFrame y ordenar por distancia
    df_coordenadas = pd.DataFrame(coordenadas)
    df_ordenado = df_coordenadas.sort_values(by='Distancia').reset_index(drop=True)


    return df_ordenado

coordenadas_ordenadas = ordenar_coordenadas(carpeta, lat_antena, lng_antena)

def procesar_archivos(df_ordenado, carpeta_datos):

    metricas_necesarias = ['RSSI', 'RSRP', 'SINR', 'RSRQ']
    resultados = []

    for _, fila in df_ordenado.iterrows():
        archivo = fila['Archivo']
        latitud = fila['Latitud']
        longitud = fila['Longitud']
        distancia = fila['Distancia']

        ruta_archivo = os.path.join(carpeta_datos, archivo)

        try:
            # Cargar el archivo
            datos = pd.read_csv(ruta_archivo)

            # Normalizar columnas
            datos.columns = datos.columns.str.strip().str.upper()

            # Verificar que las métricas necesarias existan
            if not all(metrica in datos.columns for metrica in metricas_necesarias):
                print(f"El archivo {archivo} no contiene todas las métricas necesarias.")
                continue

            # Calcular estadísticas
            stats = {f"{metrica}_mean": datos[metrica].mean() for metrica in metricas_necesarias}
            stats.update({f"{metrica}_std": datos[metrica].std() for metrica in metricas_necesarias})

            # Añadir información del archivo
            stats.update({
                "Archivo": archivo,
                "Latitud": latitud,
                "Longitud": longitud,
                "Distancia": distancia
            })

            resultados.append(stats)

        except Exception as e:
            print(f"Error al procesar el archivo {archivo}: {e}")

    # Crear un DataFrame con los resultados
    df_resultados = pd.DataFrame(resultados)
    return df_resultados

# Ruta de la carpeta con los archivos CSV
carpeta_datos = "/ruta/a/la/carpeta/DatosPathLoss"

# Procesar archivos y obtener resultados
df_resultados = procesar_archivos(coordenadas_ordenadas, carpeta_datos)

# Ver los resultados
print(df_resultados.head())

# Visualizacion de las distancias con respecto a la antena

plt.figure(figsize=(10, 6))
plt.scatter(coordenadas_ordenadas['Longitud'], coordenadas_ordenadas['Latitud'], c=coordenadas_ordenadas['Distancia'], cmap='viridis', s=50)
plt.colorbar(label='Distancia a la antena')
plt.scatter(lng_antena, lat_antena, color='red', label='Antena', s=100)  # Marcar la antena
plt.xlabel('Longitud')
plt.ylabel('Latitud')
plt.title('Coordenadas ordenadas por distancia')
plt.legend()
plt.show()

def graficar_metricas(df_resultados):

    # Definir las métricas para graficar (promedios y desviaciones estándar)
    metricas_medias = ['RSSI_mean', 'RSRP_mean', 'SINR_mean', 'RSRQ_mean']
    metricas_std = ['RSSI_std', 'RSRP_std', 'SINR_std', 'RSRQ_std']

    # Crear una figura para los gráficos
    plt.figure(figsize=(12, 8))

    # Colores para las métricas
    colores = ['blue', 'green', 'orange', 'red']

    # Generar los gráficos para cada métrica
    for i, (metrica_media, metrica_std) in enumerate(zip(metricas_medias, metricas_std)):
        # Subgráfico para cada métrica
        plt.subplot(2, 2, i+1)

        # Graficar la métrica de promedio
        plt.errorbar(df_resultados['Distancia'],
                     df_resultados[metrica_media],
                     yerr=df_resultados[metrica_std],
                     fmt='-o',
                     color=colores[i],
                     label=f'{metrica_media} ± {metrica_std}',
                     capsize=5,
                     elinewidth=2,
                     markersize=6)

        # Configuración del gráfico
        plt.title(f'{metrica_media} con desviación estándar')
        plt.xlabel('Distancia')
        plt.ylabel(metrica_media)
        plt.legend(loc='upper right')
        plt.grid(True)


    plt.tight_layout()
    plt.show()

graficar_metricas(df_resultados)

def path_loss(df_resultados, referencia_rsrp=-50):

    # Extraer las columnas necesarias
    distancias = df_resultados['Distancia']
    rsrp_medios = df_resultados['RSRP_mean']

    # Calcular Path Loss: Path Loss = Valor de referencia (dBm) - RSRP (dBm)
    path_loss = referencia_rsrp - rsrp_medios

    # Crear el gráfico
    plt.figure(figsize=(10, 6))
    plt.scatter(distancias, path_loss, color='blue', label='Path Loss', marker='o')
    plt.title('Gráfico de Path Loss', fontsize=16)
    plt.xlabel('Distancia (km)', fontsize=12)
    plt.ylabel('Potencia recibida (dBm)', fontsize=12)
    plt.grid(True)

    # Añadir una línea de ajuste si lo deseas
    # Usamos un ajuste lineal como ejemplo (este puede ajustarse más según el modelo que utilices)
    p = np.polyfit(distancias, path_loss, 1)
    plt.plot(distancias, np.polyval(p, distancias), color='red', linestyle='--', label='Ajuste lineal')

    plt.legend()
    plt.show()

path_loss(df_resultados, referencia_rsrp=-50)

def path_loss_con_error(df_resultados, referencia_rsrp=-50):

    # Extraer las columnas necesarias
    distancias = df_resultados['Distancia']
    rsrp_medios = df_resultados['RSRP_mean']
    rsrp_std = df_resultados['RSRP_std']  # Desviación estándar de RSRP

    # Calcular Path Loss: Path Loss = Valor de referencia (dBm) - RSRP (dBm)
    path_loss = referencia_rsrp - rsrp_medios

    # Crear el gráfico
    plt.figure(figsize=(10, 6))

    # Graficar el Path Loss con barras de error (error estándar de RSRP)
    plt.errorbar(distancias, path_loss, yerr=rsrp_std, fmt='o', color='blue', label='Path Loss', capsize=5)

    plt.title('Gráfico de Path Loss con Error', fontsize=16)
    plt.xlabel('Distancia (km)', fontsize=12)
    plt.ylabel('Potencia recibida (dBm)', fontsize=12)
    plt.grid(True)
    p = np.polyfit(distancias, path_loss, 1)
    plt.plot(distancias, np.polyval(p, distancias), color='red', linestyle='--', label='Ajuste lineal')
    plt.legend()
    plt.show()

path_loss_con_error(df_resultados, referencia_rsrp=-50)

def graficar_comparacion(df_resultados, f, h_b, h_m, potencia_transmitida, ciudad_grande=True):

    # Extraer las distancias, la RSRP medida y los errores asociados
    distancias = df_resultados['Distancia']
    rsrp_medios = df_resultados['RSRP_mean']
    rsrp_error = df_resultados['RSRP_std']  # Suponiendo que existe una columna de error en el DataFrame

    # Calcular el Path Loss experimental: Path Loss = Valor de referencia (dBm) - RSRP (dBm)
    referencia_rsrp = -50  # valor de referencia de RSRP (puedes ajustarlo según tus datos)
    path_loss_experimental = referencia_rsrp - rsrp_medios

    # Generar las curvas teóricas para una gama más amplia de distancias
    distancias_teoricas = np.linspace(min(distancias), max(distancias), 500)  # Rango de distancias
    path_loss_okumura_hata = okumura_hata(f, h_b, h_m, distancias_teoricas, potencia_transmitida, ciudad_grande)
    path_loss_friis = friis(f, distancias_teoricas, potencia_transmitida)

    # Crear el gráfico
    plt.figure(figsize=(10, 6))

    # Graficar la curva experimental de Path Loss con barras de error
    plt.errorbar(distancias, path_loss_experimental, yerr=rsrp_error, fmt='o', color='blue', label='Curva Experimental', capsize=5)

    # Graficar las potencias recibidas en dBm (para Okumura-Hata y Friis)
    plt.plot(distancias_teoricas, path_loss_okumura_hata, color='green', linestyle=':', label='Okumura-Hata (Potencia Recibida)')
    plt.plot(distancias_teoricas, path_loss_friis, color='red', linestyle=':', label='Friis (Potencia Recibida)')

    plt.title('Comparación de Modelos de Path Loss', fontsize=16)
    plt.xlabel('Distancia (km)', fontsize=12)
    plt.ylabel('Potencia Recibida (dBm)', fontsize=12)
    plt.grid(True)
    plt.legend()
    plt.show()

graficar_comparacion(df_resultados, f, h_b, h_m, potencia_transmitida, ciudad_grande=True)

"""Simulación RadioMobile"""

import matplotlib.pyplot as plt

# Datos de ejemplo
distancia = [ 40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,220,230,240]  # Distancia en metros
perdida_db = [ 68.3,70.2,69.8,72.8,74.0,74.5,74.1,74.4,72.1,75.7,74.4,85.4,80.1,76.3,75.4,76.5,78.9,93.2,94.9,92.6]  # Pérdida en dB

# Crear el gráfico
plt.plot(distancia, perdida_db, label='Path Loss', linewidth=2)  # Ajusta el grosor con 'linewidth'

# Títulos y etiquetas
plt.title('Relationship between Distance and Loss')  # Título del gráfico
plt.xlabel('Distance (m)')  # Etiqueta del eje x
plt.ylabel('Loss (dB)')  # Etiqueta del eje y

# Leyenda
plt.legend()

# Mostrar el gráfico
plt.grid(True)  # Mostrar la cuadrícula
plt.show()